{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"BenchBuild Documentation BenchBuild is an open-source toolkit that helps with the management of case-studies used in software-driven empirical experiments. BenchBuild was specifically designed to make defined experiments reusable between different experiment setups. It mainly provides assistance with the following standard tasks found in empirical software experiments: Add a new case-study to an existing experiment setup. Add a new experiment to an existing body of case-studies. Design Philosophy BenchBuild is designed with the following main properties in mind. A case-study doesn't know its experiment If you add a new case-study, you should never have to rely on background information about the experiment you are about to run on it. A new case-study is only concerned with its own setup of dependencies and execution during its run-time. A case-study controls where and what can be intercepted by an experiment. An experiment doesn't know its case-studies Adding a new experiment never should have any knowledge about the case-studies it runs on. A new experiment takes care of intercepting the compilation process and/or the execution procedure of a given case-study. This only defines what is being done at the defined extension points at compile-time or run-time. Supported Python Versions BenchBuild supports Python 3.7 and 3.8. Main development is focused on Python 3.8, but an effort is made to support 3.7 as long as major distributions like Debian Linux only ship with 3.7 by default. Getting started See the Installation guide for help getting BenchBuild up and running quickly.","title":"BenchBuild Documentation"},{"location":"#benchbuild-documentation","text":"BenchBuild is an open-source toolkit that helps with the management of case-studies used in software-driven empirical experiments. BenchBuild was specifically designed to make defined experiments reusable between different experiment setups. It mainly provides assistance with the following standard tasks found in empirical software experiments: Add a new case-study to an existing experiment setup. Add a new experiment to an existing body of case-studies.","title":"BenchBuild Documentation"},{"location":"#design-philosophy","text":"BenchBuild is designed with the following main properties in mind.","title":"Design Philosophy"},{"location":"#a-case-study-doesnt-know-its-experiment","text":"If you add a new case-study, you should never have to rely on background information about the experiment you are about to run on it. A new case-study is only concerned with its own setup of dependencies and execution during its run-time. A case-study controls where and what can be intercepted by an experiment.","title":"A case-study doesn&#39;t know its experiment"},{"location":"#an-experiment-doesnt-know-its-case-studies","text":"Adding a new experiment never should have any knowledge about the case-studies it runs on. A new experiment takes care of intercepting the compilation process and/or the execution procedure of a given case-study. This only defines what is being done at the defined extension points at compile-time or run-time.","title":"An experiment doesn&#39;t know its case-studies"},{"location":"#supported-python-versions","text":"BenchBuild supports Python 3.7 and 3.8. Main development is focused on Python 3.8, but an effort is made to support 3.7 as long as major distributions like Debian Linux only ship with 3.7 by default.","title":"Supported Python Versions"},{"location":"#getting-started","text":"See the Installation guide for help getting BenchBuild up and running quickly.","title":"Getting started"},{"location":"CHANGELOG/","text":"6.0.1 (2020-12-29) Bug Fixes Avoid useless plugin spam when running with higher verbosity levels ( 258bed40 , closes #354 )","title":"Release Notes"},{"location":"CHANGELOG/#601-2020-12-29","text":"","title":"6.0.1 (2020-12-29)"},{"location":"CHANGELOG/#bug-fixes","text":"Avoid useless plugin spam when running with higher verbosity levels ( 258bed40 , closes #354 )","title":"Bug Fixes"},{"location":"advanced/","text":"SLURM BenchBuild supports a high-level integration with the SLURM cluster resource manager. An experiment setup can be exported as a SLURM bash script. Assuming you have access to a configured benchbuid environment on the SLURM cluster, you can provide the SLURM script to the sbatch command and have your experiment run on the cluster environment. Basics TODO Template customization This customization is not recommended for the default use-case. However, you might run in a situation where the existing cluster-environment requires a more complicated setup than BenchBuild can provide. You can customize the template that is used for the SLURM script using a modified copy of the base template BenchBuild uses (see benchbuild/res/misc/slurm.sh.inc ). The customized template can be configured using the configuration option BB_SLURM_TEMPLATE . If BenchBuild detects that the provided value points to an existing file in your filesystem, it will load it. If you change the setting and BenchBuild cannot find a file there, no script will be generated. No validation of the template will be done, use at your own risk.","title":"SLURM"},{"location":"advanced/#slurm","text":"BenchBuild supports a high-level integration with the SLURM cluster resource manager. An experiment setup can be exported as a SLURM bash script. Assuming you have access to a configured benchbuid environment on the SLURM cluster, you can provide the SLURM script to the sbatch command and have your experiment run on the cluster environment.","title":"SLURM"},{"location":"advanced/#basics","text":"TODO","title":"Basics"},{"location":"advanced/#template-customization","text":"This customization is not recommended for the default use-case. However, you might run in a situation where the existing cluster-environment requires a more complicated setup than BenchBuild can provide. You can customize the template that is used for the SLURM script using a modified copy of the base template BenchBuild uses (see benchbuild/res/misc/slurm.sh.inc ). The customized template can be configured using the configuration option BB_SLURM_TEMPLATE . If BenchBuild detects that the provided value points to an existing file in your filesystem, it will load it. If you change the setting and BenchBuild cannot find a file there, no script will be generated. No validation of the template will be done, use at your own risk.","title":"Template customization"},{"location":"basics/","text":"Installation The installation instructions are tested against Ubuntu 20.04 for Python 3.7 and Python 3.8. The particular commands required for installation depend on your setup. The dependencies below are not always mandatory, if they are not used. Requirements Dependency Minimum Version Notes Python 3.7 libpq 9.6 Required by psycopg2. libfuse 2.9.9 If uchroot is used. unionfs-fuse 1.0 If unionfs support is used. slurm-llnl 18.08 If slurm support is used. PostgreSQL The library dependency libpq is always need right now, because we make use of psycopg2 features internally. It is planned to get rid of this dependency in the future. FUSE BenchBuild can make use of unionfs and libfuse . This is often used in conjunction with a tool named uchroot which provides legacy support for user-space containers. This will be obsolete as soon as podman / buildah based OCI container support is considered stable. SLURM The cluster management software slurm is only required by 'name', i.e., we have to be able to import the binaries as python objects in benchbuild. As an alternative to installing slurm on your machine, you can always provide symlinks to /bin/true to the commands sbatch and srun . The minimum version should signal the minimum features set expected by BenchBuild when generating a slurm batch script. Benchbuild BenchBuild is released via pip and can be installed on your system as follows: pip install benchbuild [1] ( ) (b a s h) ( ) If you want to isolate BenchBuild from the rest of your system packages, you can install it in a dedicated virtual environment. virtualenv -ppython3 <venv_path> source <venv_path>/bin/activate pip3 install benchbuild [2] ( ) (b a s h) ( ) Bootstrapping BenchBuild provides a bootstrap procedure that checks a few key binaries on your system and tries to assist you in installation of any necessary binaries.","title":"Installation"},{"location":"basics/#installation","text":"The installation instructions are tested against Ubuntu 20.04 for Python 3.7 and Python 3.8. The particular commands required for installation depend on your setup. The dependencies below are not always mandatory, if they are not used.","title":"Installation"},{"location":"basics/#requirements","text":"Dependency Minimum Version Notes Python 3.7 libpq 9.6 Required by psycopg2. libfuse 2.9.9 If uchroot is used. unionfs-fuse 1.0 If unionfs support is used. slurm-llnl 18.08 If slurm support is used.","title":"Requirements"},{"location":"basics/#postgresql","text":"The library dependency libpq is always need right now, because we make use of psycopg2 features internally. It is planned to get rid of this dependency in the future.","title":"PostgreSQL"},{"location":"basics/#fuse","text":"BenchBuild can make use of unionfs and libfuse . This is often used in conjunction with a tool named uchroot which provides legacy support for user-space containers. This will be obsolete as soon as podman / buildah based OCI container support is considered stable.","title":"FUSE"},{"location":"basics/#slurm","text":"The cluster management software slurm is only required by 'name', i.e., we have to be able to import the binaries as python objects in benchbuild. As an alternative to installing slurm on your machine, you can always provide symlinks to /bin/true to the commands sbatch and srun . The minimum version should signal the minimum features set expected by BenchBuild when generating a slurm batch script.","title":"SLURM"},{"location":"basics/#benchbuild","text":"BenchBuild is released via pip and can be installed on your system as follows: pip install benchbuild [1] ( ) (b a s h) ( ) If you want to isolate BenchBuild from the rest of your system packages, you can install it in a dedicated virtual environment. virtualenv -ppython3 <venv_path> source <venv_path>/bin/activate pip3 install benchbuild [2] ( ) (b a s h) ( )","title":"Benchbuild"},{"location":"basics/#bootstrapping","text":"BenchBuild provides a bootstrap procedure that checks a few key binaries on your system and tries to assist you in installation of any necessary binaries.","title":"Bootstrapping"},{"location":"basics/configuration/","text":"","title":"Configuration"},{"location":"basics/containers/","text":"Benchbuild allows the definition of container images to define the base system all experiment runs run in for a given project. Usage If you want to run an experiment inside the project's container, simply replace the usual run subcommand with the container run subcommand. Project and experiment selection are done in the same way. Example: benchbuild container run -E raw linpack [1] ( ) ( ) This will run the following stages: Build all necessary base images. All images are initiated from a base image. Benchbuild knows how to construct a few base images. These will be prepared with all dependencies required to run benchbuild inside the container. Build all project images. Each project has to define its' own image. Build the experiment images. Each experiment can add anything it needs to the project images, if required. Use this to bring tools into the image that do not require any knowledge about the environment to run properly. For anything else, consider using a custom base image. Replace Images Benchbuild will reuse any existing images it can find in your image registry. The only relevant information is the image tag, e.g., benchbuild:alpine . If you want to avoid reuse and force to rebuild images unconditionally, you can use the --replace flag when running the containers subcommand. Example: benchbuild container run --replace -E raw linpack [2] ( ) ( ) This will ignore any required image for the given experiments and projects. Configuration You can configure the container environment using the following config variables. BB_CONTAINER_EXPORT : Path where benchbuild stores exported container images. By default we store it in ./containers/export . Will be created automatically, if needed. BB_CONTAINER_IMPORT : Path where to input images from into the registry. By default we load from ./containers/export . BB_CONTAINER_FROM_SOURCE : Determine, if we should use benchbuild from the current source checkout, or from pip. BB_CONTAINER_ROOT : Where we store our image layers. This is the image registry. Cannot be stored on filesystems that do not support subuid/-gid mapping, e.g. NFS. The default location is ./containers/lib . BB_CONTAINER_RUNROOT : Where we store temporary image layers of running containers. See BB_CONTAINER_ROOT for restrictions. The default location is: ./containers/run . BB_CONTAINER_RUNTIME : Podman can use any standard OCI-container runtime to launch containers. We use crun by default. Depending on your system, this one has already been installed with podman . The default runtime is: /usr/bin/crun BB_CONTAINER_MOUNTS : A list of mountpoint definitions that should be added to all containers. With this you can add arbitrary tools into all containers. Default: [] Definition A project that wants to use a container image needs to define it in the CONTAINER attribute it using our declarative API provided by benchbuild.environments.domain.declarative . from benchbuild.environments.domain.declarative import ContainerImage class Testproject(Project): CONTAINER = ContainerImage().from_('benchbuild:alpine') [3] ( ) ( ) The available set of commands follows the structure of a Dockerfile . Runtime requirements For containers to work properly, you need a few systems set up beforehand. Buildah Image construction requires the Buildah tool. All image construction tasks are formulated as buildah command calls in the backend. Buildah is supported up to version 1.19.8. Podman Container construction and execution is handed off to Podman . Podman provides rootless containers and does not requires the execution of a daemon process. However, you need to setup your user namespace properly to allow mapping of subordinate uids/gids. Otherwise, podman will not be able to map users other than the root user to filesystem permissions inside the container. Please refer to podman's documentation on how to setup podman properly on your system. Podman is supported up to version 2.2.1","title":"Containers"},{"location":"basics/containers/#usage","text":"If you want to run an experiment inside the project's container, simply replace the usual run subcommand with the container run subcommand. Project and experiment selection are done in the same way. Example: benchbuild container run -E raw linpack [1] ( ) ( ) This will run the following stages: Build all necessary base images. All images are initiated from a base image. Benchbuild knows how to construct a few base images. These will be prepared with all dependencies required to run benchbuild inside the container. Build all project images. Each project has to define its' own image. Build the experiment images. Each experiment can add anything it needs to the project images, if required. Use this to bring tools into the image that do not require any knowledge about the environment to run properly. For anything else, consider using a custom base image.","title":"Usage"},{"location":"basics/containers/#replace-images","text":"Benchbuild will reuse any existing images it can find in your image registry. The only relevant information is the image tag, e.g., benchbuild:alpine . If you want to avoid reuse and force to rebuild images unconditionally, you can use the --replace flag when running the containers subcommand. Example: benchbuild container run --replace -E raw linpack [2] ( ) ( ) This will ignore any required image for the given experiments and projects.","title":"Replace Images"},{"location":"basics/containers/#configuration","text":"You can configure the container environment using the following config variables. BB_CONTAINER_EXPORT : Path where benchbuild stores exported container images. By default we store it in ./containers/export . Will be created automatically, if needed. BB_CONTAINER_IMPORT : Path where to input images from into the registry. By default we load from ./containers/export . BB_CONTAINER_FROM_SOURCE : Determine, if we should use benchbuild from the current source checkout, or from pip. BB_CONTAINER_ROOT : Where we store our image layers. This is the image registry. Cannot be stored on filesystems that do not support subuid/-gid mapping, e.g. NFS. The default location is ./containers/lib . BB_CONTAINER_RUNROOT : Where we store temporary image layers of running containers. See BB_CONTAINER_ROOT for restrictions. The default location is: ./containers/run . BB_CONTAINER_RUNTIME : Podman can use any standard OCI-container runtime to launch containers. We use crun by default. Depending on your system, this one has already been installed with podman . The default runtime is: /usr/bin/crun BB_CONTAINER_MOUNTS : A list of mountpoint definitions that should be added to all containers. With this you can add arbitrary tools into all containers. Default: []","title":"Configuration"},{"location":"basics/containers/#definition","text":"A project that wants to use a container image needs to define it in the CONTAINER attribute it using our declarative API provided by benchbuild.environments.domain.declarative . from benchbuild.environments.domain.declarative import ContainerImage class Testproject(Project): CONTAINER = ContainerImage().from_('benchbuild:alpine') [3] ( ) ( ) The available set of commands follows the structure of a Dockerfile .","title":"Definition"},{"location":"basics/containers/#runtime-requirements","text":"For containers to work properly, you need a few systems set up beforehand.","title":"Runtime requirements"},{"location":"basics/containers/#buildah","text":"Image construction requires the Buildah tool. All image construction tasks are formulated as buildah command calls in the backend. Buildah is supported up to version 1.19.8.","title":"Buildah"},{"location":"basics/containers/#podman","text":"Container construction and execution is handed off to Podman . Podman provides rootless containers and does not requires the execution of a daemon process. However, you need to setup your user namespace properly to allow mapping of subordinate uids/gids. Otherwise, podman will not be able to map users other than the root user to filesystem permissions inside the container. Please refer to podman's documentation on how to setup podman properly on your system. Podman is supported up to version 2.2.1","title":"Podman"},{"location":"concepts/environments/","text":"Environment","title":"Environment"},{"location":"concepts/environments/#environment","text":"","title":"Environment"},{"location":"concepts/experiments/","text":"Experiment TODO.","title":"Experiment"},{"location":"concepts/experiments/#experiment","text":"TODO.","title":"Experiment"},{"location":"concepts/projects/","text":"Project TODO.","title":"Project"},{"location":"concepts/projects/#project","text":"TODO.","title":"Project"},{"location":"concepts/source/","text":"Source TODO. General Versioning HTTP Git Rsync TODO.","title":"Source"},{"location":"concepts/source/#source","text":"TODO.","title":"Source"},{"location":"concepts/source/#general","text":"","title":"General"},{"location":"concepts/source/#versioning","text":"","title":"Versioning"},{"location":"concepts/source/#http","text":"","title":"HTTP"},{"location":"concepts/source/#git","text":"","title":"Git"},{"location":"concepts/source/#rsync","text":"TODO.","title":"Rsync"}]}